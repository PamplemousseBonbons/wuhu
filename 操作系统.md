# 第 1 章 计算机系统概述

## 1.1 操作系统的基本概念

## 1.1.1 操作系统的概念、功能和目标（系统资源的管理者、提供接口、作为扩充机器、虚拟机）







### 1.熟悉的操作系统举例

![在这里插入图片描述](F:\bilibili\大笔记\操作系统.assets\2020022012313767.png)

## 2.操作系统的层次结构

![在这里插入图片描述](F:\bilibili\大笔记\操作系统.assets\20200220125305234.png)

## 3.操作系统的概念

- 是系统最基本最核心的软件，属于系统软件
- 控制和管理整个计算机的硬件和软件资源
- 合理的组织、调度计算机的工作与资源的分配
- 为用户和其它软件提供方便的接口和环境
  ![在这里插入图片描述](F:\bilibili\大笔记\操作系统.assets\20200220130754779.png)

## 4.操作系统的功能和目标

- 先放一张思维导图，大致知道操作系统的具体功能和目标，然后再一一展开叙述。
  ![在这里插入图片描述](F:\bilibili\大笔记\操作系统.assets\20200220181209621.png)
- 用一个直观的例子来理解上述图中操作系统的功能：

> - 我们假设：用户是雇主，操作系统是工人（用来操作机器），计算机是机器（由处理机(CPU)、存储器、设备、文件几个部件构成）
> - 工人有熟练的技能去控制和协调各个部件的工作，这就是`操作系统对资源的管理`
> - 同时，工人必须接受雇主的命令，这就是`“接口”`
> - 有了工人，机器就能发挥更大的作用，因此工人就成了`“扩充机器”`
> - 工人操作机器、机器有了更大的作用比如GUI界面，于是工人便成了`扩充机器`，去扩充GUI界面等功能

### （1）作为计算机系统资源的管理者

- 管理软硬件资源、合理的组织、调度计算机的工作与资源的分配
  ![在这里插入图片描述](F:\bilibili\大笔记\操作系统.assets\20200220175206746.png)

#### 1️⃣处理器（CPU）管理

- 在多道程序环境下，cpu的分配和运行都以进程（或线程）为基本单位，因此对cpu的管理可理解为对进程的管理。进程管理的主要功能包括`进程控制、进程同步、进程通信、死锁处理、处理机调度`等。附上一张图理解对进程的管理。
  ![在这里插入图片描述](F:\bilibili\大笔记\操作系统.assets\20200220174054546.png)

#### 2️⃣存储器管理

- 为多道程序的运行提供良好的环境，方便用户使用及提高内存的利用率，主要包括`内存分配与回收、地址映射、内存保护与共享和内存扩充`等功能。
  ![在这里插入图片描述](F:\bilibili\大笔记\操作系统.assets\20200220174345586.png)

#### 3️⃣文件管理

- 计算机中所有的信息都是以文件的形式存在的，操作系统中负责文件的管理的部分称为文件系统，文件管理包括`文件存储空间的管理、目录管理及文件读写管理和保护`等。
  ![在这里插入图片描述](F:\bilibili\大笔记\操作系统.assets\20200220175651564.png)

#### 4️⃣设备管理

- 设备管理的主要任务是完成用户的I/O请求，方便用户使用各种设备，并提高设备的利用率，主要`包括缓存管理、设备分配、设备处理和虚拟设备`等功能。
  ![在这里插入图片描述](F:\bilibili\大笔记\操作系统.assets\20200220180110573.png)
- 以上4种管理功能都由“工人”负责，“雇主”无序关注。

### （2）作为用户与计算机硬件系统之间的接口

- 为了让用户方便、快捷、可靠的操作计算机硬件并执行自己的程序，操作系统提供了用户接口
- 操作系统提供的接口分为两类：`命令接口和程序接口`
- `命令接口`：用户可以`直接`使用的，利用这些操作命令来组织和控制作业的执行
- `程序接口`：用户通过程序`间接`使用的，编程人员可以使用它们来请求操作系统服务
  ![在这里插入图片描述](F:\bilibili\大笔记\操作系统.assets\20200220181548282.png)

#### 1️⃣命令接口

- 命令接口分为两类：联机命令接口和脱机命令接口，用户可以`直接`调用

- ```
  联机命令接口：又称交互式命令接口
  ```

  适用于分时或实时系统的接口，由一组键盘操作命令组成。用户输入一条指令，操作系统就执行一条指令；
  ![在这里插入图片描述](F:\bilibili\大笔记\操作系统.assets\20200220182355987.png)

- ```
  脱机命令接口：又称批处理接口
  ```

  使用于批处理系统，由一组作业控制命令组成。用户输入一堆指令，操作系统运行一堆指令。在操作系统运行这些命令时用户不可干预。

  > 批处理(Batch)，也称为批处理脚本。顾名思义，批处理就是对某对象进行批量的处理，通常被认为是一种简化的脚本语言，它应用于DOS和Windows系统中。批处理文件的扩展名为==bat==。![在这里插入图片描述](F:\bilibili\大笔记\操作系统.assets\20200220182828410.png)

#### 2️⃣程序接口

- 程序接口：由一组`系统调用（也称广义指令）`组成
- 用户通过在程序中使用这些系统调用来请求操作系统为其提供服务，只能通过用户程序`间接`调用
- 如使用各种外部设备、申请分配和回收内存及其它各种要求
  ![在这里插入图片描述](F:\bilibili\大笔记\操作系统.assets\2020022018383578.png)

> 动态链接库英文为DLL，是Dynamic Link Library的缩写。DLL是一个包含可由多个程序，同时使用的代码和数据的库。

常见的图形用户界面程序接口GUI
![在这里插入图片描述](F:\bilibili\大笔记\操作系统.assets\20200220184655178.png)
![在这里插入图片描述](F:\bilibili\大笔记\操作系统.assets\20200220184339565.png)

- ![image-20210526134418232](F:\bilibili\大笔记\操作系统.assets\image-20210526134418232.png)

### （3）作为扩充机器（虚拟机）

![在这里插入图片描述](F:\bilibili\大笔记\操作系统.assets\20200220184843350.png)

- 没有任何软件支持的计算机称为`裸机`
- 覆盖了软件的机器称为`扩充机器或虚拟机`
  ![在这里插入图片描述](F:\bilibili\大笔记\操作系统.assets\20200220185203629.png)

![image-20210526134758183](F:\bilibili\大笔记\操作系统.assets\image-20210526134758183.png)

## 1.1.2 操作系统的特征（并发、共享、虚拟、异步）

- 操作系统是一种系统软件，但与其它系统软件和应用软件有很大的不同，它有自己的特殊性，及基本特征。

  ![image-20210526135112408](F:\bilibili\大笔记\操作系统.assets\image-20210526135112408.png)

![在这里插入图片描述](F:\bilibili\大笔记\操作系统.assets\20200220220130442.png)

### 1.并发

![image-20210526135225956](F:\bilibili\大笔记\操作系统.assets\image-20210526135225956.png)

- `并发`：两个或多个事件在==同一时间间隔内==发生，这些事件==在宏观上是同时发生的，在微观上是交替发生的==， 操作系统的并发性指系统中同时存在着多个运行的程序
- `并行`：两个或多个事件在==同一时刻==发生
- 一个单核(CPU)同一时刻 只能执行一个程序，因此操作系统会协调多个程序使他们交替进行（这些程序在宏观上是同时发生的，在微观上是交替进行的）
- 操作系统是伴随着“多道程序技术出现的”，因此操作系统和并发是一同诞生的
- 单核CPU同一时刻只能执行一个程序，各个程序只能并发地执行
  多核CPU同一时刻可以同时执行多个程序，多个程序可以并行地执行

### 2.共享

![image-20210526141456555](F:\bilibili\大笔记\操作系统.assets\image-20210526141456555.png)

- 资源共享即共享，是指系统中的资源可以`供内存中多个并发执行的进程`共同使用
- 共享分为两类：互斥共享和同时共享

#### （1）互斥共享

- 计算机中的某个资源在一段时间内只能允许`一个进程`访问，别的进程没有使用权
- 临界资源(独占资源)：在一段时间内只允许一个进程访问的资源，计算机中大多数物理设备及某些软件中的栈、变量和表格都属于临界资源，它们被要求互斥共享
- 举个例子：比如QQ和微信视频。同一段时间内摄像头只能分配给其中一个进程

#### （2）同时共享

- 计算机中的某个资源在在一段时间内可以`同时`允许`多个`进程访问
- 同时共享通常要求一个请求分为几个时间片段间隔的完成，即交替进行，“分时共享”
- 这里的`同时`指在宏观上是同时的，在微观上是交替进行访问的，只是cpu处理速度很快，我们感觉不到，在宏观上感觉是在同时进行
- 举个例子：比如QQ在发送文件A，微信在发送文件B，宏观上两个进程A和B都在访问磁盘，在我们看来是同时进行的，但是在微观上两个进程A和B是交替进行访问磁盘的，只是时间太短，cpu处理速度太快，我们感觉不到。
- `注意`：有时候多个进程可能真的是在同时进行资源访问，比如玩游戏时可以放音乐，游戏声音和音乐声音都能听见

#### （3）并发性和共享性 互为存在条件

![在这里插入图片描述](F:\bilibili\大笔记\操作系统.assets\20200220204551232.png)

### 3.虚拟

> 多道程序设计：是指在计算机内存中同时存放几道相互独立的程序，使它们在管理程序控制之下，相互穿插的运行。 两个或两个以上程序在计算机系统中同处于开始到结束之间的状态。这就称为多道程序设计。多道程序技术运行的特征：多道、宏观上并行、微观上串行。

- 虚拟是把一个物理上的实体变为若干逻辑上的对应物。
- 物理实体（前者）是实际存在的；而后者是虚的，是用户感觉上的事务
- 虚拟技术：用于实现虚拟的技术
- 虚拟处理器（CPU）：通过多道程序设计技术，采用让多道程序并发执行的方法，分时来使用一个CPU，实际物理上只有一个CPU，但是用户感觉到有多个CPU
- ![image-20210526142108126](F:\bilibili\大笔记\操作系统.assets\image-20210526142108126.png)
- 虚拟存储器：从逻辑上扩充存储器容量，用户感觉到的但实际不存在的存储器
- ![image-20210526142122741](F:\bilibili\大笔记\操作系统.assets\image-20210526142122741.png)
- 虚拟设备：将一台物理设备虚拟为逻辑上的多台设备，使多个用户在同一时间段内访问同一台设备，即同时共享，用户宏观上感觉是同时的，但实际上是微观交替访问同一台设备的
- 操作系统的虚拟技术科归纳为：
  - 时分复用技术：如处理器的分时共享
  - 空间复用技术：如虚拟存储器
    ![在这里插入图片描述](F:\bilibili\大笔记\操作系统.assets\20200220215401443.png)

### 4.异步

- 异步：多道程序环境允许多个程序`并发`执行，但由于资源有限，如cpu只有一个，进程的执行并不是一贯到底的，而是走走停停的，它以不可预知的速度向前推进。
- 比如A进程正在占用CPU计算，B进程这时也想占用CPU计算，B进程只有等，等A进程算完了，A进程去访问磁盘资源了，这时B进程再占用CPU进行计算，B进程还没计算完，A进程从磁盘取出资源了，A进程发现B这时在占用CPU，这时A进程就需要等待，等B算完后再继续到CPU中进行计算。由于每个进程占用资源的时间不固定，所以进程的执行以不可预知的速度前进
- 如果失去了并发性，即系统只能串行地运行各个程序，那么每个程序的执行会一贯到底。`只有系统拥有并发性，才有可能导致异步性。`

### 小结

![image-20210526150129034](F:\bilibili\大笔记\操作系统.assets\image-20210526150129034.png)

## 操作系统的发展与分类

> 知识总览
>
> ![img](F:\bilibili\大笔记\操作系统.assets\20210505102720400.png)

> ```
> 学习提示：要重点关注和理解各类操作系统主要想解决的是什么问题，各自的优缺点。
> ```

### 手工操作阶段

![在这里插入图片描述](F:\bilibili\大笔记\操作系统.assets\20210505102735876.png)

### 批处理阶段——单道批处理系统

引入脱机输入 / 输出技术（用外围机+磁带完成），并由监督程序负责控制作业的输入、输出

![在这里插入图片描述](F:\bilibili\大笔记\操作系统.assets\20210505102749493.png)

主要优点：缓解了一定程度的人机速度矛盾，资源利用率有所提升。

主要缺点：内存中仅能有一道程序运行，只有该程序运行结束之后才能调入下一道程序。CPU有大量的时间是在空闲等待I/O完成。资源利用率依然很低。

### 批处理阶段——多道批处理系统

每次往内存中读入多道程序

操作系统正式诞生，用于支持多道程序并发运行

![在这里插入图片描述](F:\bilibili\大笔记\操作系统.assets\20210505102807259.png)

主要优点：多道程序==并发执行==，==共享计算机资源==。资源利用率大幅提升，CPU和其他资源更能保持“忙碌”状态，系统吞吐量z增大

主要缺点：用户响应时间长，没有人机交互功能（用户提交自己的作业之后就只能等待计算机处理完成，中间不能控制自己的作业执行。eg：无法调试程序 / 无法在程序运行过程中输入一些参数）

### 分时操作系统

分时操作系统：计算机以时间片为单位轮流为各个用户 / 作业服务，各个用户可通过终端与计算机进行交互。

![img](F:\bilibili\大笔记\操作系统.assets\20210505102819547.png)

主要优点：用户请求可以被即时响应，解决了人机交互问题。允许多个用户同时使用一台计算机，并且用户对计算机的操作相互独立，感受不到别人的存在。

主要缺点：不能优先处理一些紧急任务。操作系统对各个用户 / 作业都是完全公平的，循环地为每个用户 /作业服务一个时间片，不区分任务的紧急性。

### 实时操作系统

主要优点：能够优先响应一些紧急任务，某些紧急任务不需时间片排队。

在实时操作系统的控制下，计算机系统接收到外部信号后及时进行处理，并且要在严格的时限内处理完事件。实时操作系统的主要特点是及时性和可靠性

![在这里插入图片描述](F:\bilibili\大笔记\操作系统.assets\20210505102838859.png)

### 其他几种操作系统

网络操作系统：是伴随着计算机网络的发展而诞生的，能把网络中各个计算机有机地结合起来，实现数据传送等功能，实现网络中各种资源的共享（如文件共享）和各台计算机之间的通信。（如：Windows NT 就是一种典型的网络操作系统，网站服务器就可以使用）

分布式操作系统：主要特点是分布性和并行性。系统中的各台计算机地位相同，任何工作都可以分布在这些计算机上，由它们并行、协同完成这个任务。

个人计算机操作系统：如Windows XP、MacOS，方便个人使用。

![image-20210526154217651](F:\bilibili\大笔记\操作系统.assets\image-20210526154217651.png)

## OS的运行机制和体系结构

> 知识总览
>
> ![img](F:\bilibili\大笔记\操作系统.assets\20210505102905117.png)

### 什么是指令

问题:“指令” 和我们平时所说的“代码”有什么区别?

![在这里插入图片描述](F:\bilibili\大笔记\操作系统.assets\20210505102916245.png)

### 两种指令、两种处理器状态、两种程序

#### 两种指令

有的指令“人畜无害”。比如:加、减、乘、除这些普通的运算指令。

有的指令有很高的权限。比如:内存清零指令。如果用户程序可以使用这个指令，就意味着一个用户可以将其他用户的内存数据随意清零，这样做显然是很危险的。

![在这里插入图片描述](F:\bilibili\大笔记\操作系统.assets\20210505102929486.png)

#### 两种处理器状态

> CPU如何判断当前是否可以执行特权指令?
>
> ![在这里插入图片描述](F:\bilibili\大笔记\操作系统.assets\20210505102948643.png)

#### 两种程序

![在这里插入图片描述](F:\bilibili\大笔记\操作系统.assets\20210505103001827.png)

#### 小结

![在这里插入图片描述](F:\bilibili\大笔记\操作系统.assets\20210505103014559.png)

### 操作系统内核

Yo~生活经验:我们安装完Windows操作系统后，会发现操作系统提供了多种多样的功能，比如“记事本”、“任务管理器”。然而，这些功能并不是必不可少的。即使没有“任务管理器”，我们仍然可以使用计算机。

![在这里插入图片描述](F:\bilibili\大笔记\操作系统.assets\20210505103031148.png)

> 内核是计算机上配置的底层软件，是操作系统最基本、最核心的部分。
>
> ![在这里插入图片描述](https://img-blog.csdnimg.cn/20210505103051617.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDA3NTEzMg==,size_16,color_FFFFFF,t_70)

#### 大内核 微内核

![在这里插入图片描述](F:\bilibili\大笔记\操作系统.assets\20210505103101929.png)

#### 操作系统体系结构

![在这里插入图片描述](F:\bilibili\大笔记\操作系统.assets\2021050510311258.png)

![image-20210526160318405](F:\bilibili\大笔记\操作系统.assets\image-20210526160318405.png)

### 中断和异常

> 知识总览
>
> ![在这里插入图片描述](F:\bilibili\大笔记\操作系统.assets\20210505103122482.png)



#### 中断的作用

![image-20210526160910302](F:\bilibili\大笔记\操作系统.assets\image-20210526160910302.png)

CPU 上会运行两种程序，一种是操作系统内核程序，一种是应用程序

> “中断”会使CPU由用户态变为内核态，使操作系统重新夺回对CPU的控制权

在合适的情况下，操作系统内核会把CPU的使用权主动让给应用程序（第二章进程管理相关内容）

==“中断”是让操作系统内核夺回CPU使用权的唯一途径==

> 如果没有“中断”机制，那么一旦应用程序上CPU运行，CPU就会一直运行这个应用程序

内核态 → 用户态：执行一条特权指令——`修改PSW的标志位为“用户态”`，这个动作意味着操作系统将主动让出CPU使用权

用户态 → 内核态：由“中断”引发，`硬件自动完成变态过程`，触发中断信号意味着操作系统将强行夺回CPU的使用权

#### 中断的类型

![image-20210526161033213](F:\bilibili\大笔记\操作系统.assets\image-20210526161033213.png)

![image-20210526170357215](F:\bilibili\大笔记\操作系统.assets\image-20210526170357215.png)

![在这里插入图片描述](F:\bilibili\大笔记\操作系统.assets\20210505103142909.png)

##### 内中断

与当前执行的指令有关，中断信号来源于CPU内部

内中断: CPU在执行指令时会检查是否有异常发生

![在这里插入图片描述](F:\bilibili\大笔记\操作系统.assets\20210505103210520.png)

例子1：试图在用户态下执行特权指令

例子2：执行除法指令时发现除数为 0 **若当前执行的指令是非法的，则会引发一个中断信号**

例子3：有时候应用程序想请求操作系统内核的服务，此时会执行一条特殊的指令——`陷入指令`，该指令会引发一个内部中断信号

> ```
> 执行“陷入指令”，意味着应用程序主动地将CPU控制权还给操作系统内核。“系统调用”就是通过陷入指令完成的
> ```

##### 外中断

- 每一条指令执行结束时，CPU都会例行检查是否有外中断信号
- 与当前执行的指令无关，中断信号来源于CPU外部

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210505103248611.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDA3NTEzMg==,size_16,color_FFFFFF,t_70)

例子1：时钟中断——由时钟部件发来的中断信号

例子2：I/O中断——由输入 / 输出设备发来的中断信号

![image-20210526171015610](F:\bilibili\大笔记\操作系统.assets\image-20210526171015610.png)

##### 小结

![在这里插入图片描述](F:\bilibili\大笔记\操作系统.assets\20210505103259306.png)

#### 中断机制的基本原理

不同的中断信号，需要用不同的中断处理程序来处理。当CPU检测到中断信号后，会根据中断信号的类型去查询`“中断向量表”`，以此来找到相应的中断处理程序在内存中的存放位置。

![在这里插入图片描述](F:\bilibili\大笔记\操作系统.assets\20210505103309742.png)

#### 小结

![在这里插入图片描述](F:\bilibili\大笔记\操作系统.assets\20210505103321662.png)

![image-20210526171944328](F:\bilibili\大笔记\操作系统.assets\image-20210526171944328.png)

### 系统调用

> 知识总览
>
> ![在这里插入图片描述](F:\bilibili\大笔记\操作系统.assets\20210505103335912.png)

#### 什么是系统调用，有何作用？

应用程序中，凡是与资源有关的操作，都必须通过 系统调用 的方式向操作系统提出服务请求，由操作系统代为完成。

系统调用 需要执行 特权指令 因此需要在核心态下

![image-20210526221135479](F:\bilibili\大笔记\操作系统.assets\image-20210526221135479.png)

![在这里插入图片描述](F:\bilibili\大笔记\操作系统.assets\20210505103350817.png)

操作系统作为用户和计算机硬件之间的接口，需要向上提供一些简单易用的服务。主要包括命令接口和程序接口。其中`程序接口由一组系统调用组成`。

“系统调用”是操作系统提供给应用程序（程序员 / 编程人员）使用的接口，可以理解为一种可供应用程序调用的特殊函数，应用程序可以通过系统调用来请求`获得操作系统内核的服务`

#### 系统调用与库函数的区别

![在这里插入图片描述](F:\bilibili\大笔记\操作系统.assets\20210505103406406.png)

最下层是裸机，

| 普通应用程序 | 可直接进行系统调用，也可使用库函数。有的库函数涉及系统调用，有的不涉及 |      |
| ------------ | ------------------------------------------------------------ | ---- |
| 编程语言     | 向上提供库函数。有时会将系统调用封装成库函数，以隐藏系统调用的一些细节使程序员编程更加方便。 |      |
| 操作系统     | 向上提供系统调用，使得上层程序能请求内核的服务               |      |
| 裸机         |                                                              |      |

不涉及系统调用的库函数：如的“取绝对值”的函数

涉及系统调用的库函数：如“创建一个新文件”的函数，涉及到对系统中 共享资源的操作

#### 小例子：为什么系统调用是必须的？

生活场景：去学校打印店打印论文，你按下了WPS 的“打印”选项，打印机开始工作。你的论文打印到一半时，另一位同学按下了Word 的“打印”按钮，开始打印他自己的论文。

思考：如果两个进程可以随意地、并发地共享打印机资源，会发生什么情况？

两个进程并发运行，打印机设备交替地收到WPS 和Word 两个进程发来的打印请求，结果两篇论文的内容混杂在一起了…

解决方法：由操作系统内核对共享资源进行统一的管理，并向上提供“系统调用”，用户进程想要使用打印机这种共享资源，只能通过系统调用向操作系统内核发出请求。内核会对各个请求进行协调处理。

#### 什么功能要用到系统调用？

应用程序通过系统调用请求操作系统的服务。而系统中的各种共享资源都由操作系统内核统一掌管，因此`凡是与共享资源有关的操作（如存储分配、I/O操作、文件管理等），都必须通过系统调用的方式向操作系统内核提出服务请求`，由操作系统内核代为完成。这样可以保证系统的`稳定性和安全性`，防止用户进行非法操作。

![在这里插入图片描述](F:\bilibili\大笔记\操作系统.assets\20210505103431734.png)

#### 系统调用的过程

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210505103445438.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDA3NTEzMg==,size_16,color_FFFFFF,t_70)

![image-20210526223352742](F:\bilibili\大笔记\操作系统.assets\image-20210526223352742.png)

传递系统调用参数—>执行陷入指令（用户态）—> 执行相应的内请求核程序处理系统调用（核心态）—>返回

应用程序
注意：

1. 陷入指令是在用户态执行的，执行陷入指令之后立即引发一个内中断，使CPU进入核心态
2. ==发出系统调用请求是在用户态，而对系统调用的相应处理在核心态下进行==
3. 陷入指令是唯一一个，只能在用户态执行，不能再核心态下执行的指令

#### 小结

![image-20210526223615960](F:\bilibili\大笔记\操作系统.assets\image-20210526223615960.png)







# 二、进程管理

# 进程

## 进程的概念

### 进程的定义

==程序:就是一个指令序列。==

程序段、数据段、PCB三部分组成了`进程实体`(进程映像)。一般情况下，我们把进程实体就简称为进程,例如，所谓创建进程，实质上是创建进程实体中的PCB;而撤销进程，实质上是撤销进程实体中的PCB。

- PCB：系统为每个运行的程序配置一个数据结构，成为进程控制块（PCB）。

> PCB是进程存在的唯一标志 !

从不同的角度，进程可以有不同的定义，比较传统典型的定义有:
1.进程是程序的一次**执行过程**。
2.进程是一个程序及其数据在处理机上顺序执行时所**发生的活动**。
3.进程是具有独立功能的程序在数据集合上**运行的过程**，它是系统进行资源分配和调度的一个独立单位。

进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。

注:严格来说，进程实体和进程并不一样，进程实体是静态的，进程则是动态的。

### 进程的组成

![image-20210526225326474](F:\bilibili\大笔记\操作系统.assets\image-20210526225326474.png)

![image-20210526225514350](F:\bilibili\大笔记\操作系统.assets\image-20210526225514350.png)



`进程(进程实体)`由程序段、数据段、PCB三 部分组成。

![在这里插入图片描述](F:\bilibili\大笔记\操作系统.assets\20210505221509898.png)

> ==进程的管理者(操作系统)所需的数据都在PCB中==
>
> 程序本身的运行所需的数据存放在程序段和数据段中

![在这里插入图片描述](F:\bilibili\大笔记\操作系统.assets\20210505221519928.png)

#### PCB

系统为每个运行的程序配置一个数据结构，成为进程控制块（PCB）。

![img](F:\bilibili\大笔记\操作系统.assets\202105052215334.png)

### 进程的组织方式

在一个系统中，通常有数十、数百乃至数千个PCB。为了能对他们加以有效的管理，应该用适当的方式把这些PCB组织起来。

注:进程的组成讨论的是一个进程内部由哪些部分构成的问题，而进程的组织讨论的是多个进程之间的组织方式问题

![img](F:\bilibili\大笔记\操作系统.assets\20210505221547119.png)

#### 链接方式，指向队列

![在这里插入图片描述](F:\bilibili\大笔记\操作系统.assets\20210505221601693.png)

#### 索引方式，指向索引表

![在这里插入图片描述](F:\bilibili\大笔记\操作系统.assets\202105052216120.png)

### 进程的特征

==进程是程序的一次执行过程==



![在这里插入图片描述](F:\bilibili\大笔记\操作系统.assets\2021050522162225.png)

### 小结

![image-20210526230549766](F:\bilibili\大笔记\操作系统.assets\image-20210526230549766.png)



## 进程状态及转换

![image-20210527143622582](F:\bilibili\大笔记\操作系统.assets\image-20210527143622582.png)

### 三种基本状态

进程是程序的一次执行。在这个执行过程中，有时进程正在被CPU处理，有时又需要等待CPU服务，可见，进程的状态是会有各种变化。为了方便对各个进程的管理，操作系统需要将进程合理地划分为几种状态。

![img](F:\bilibili\大笔记\操作系统.assets\2021050614465518.png)

注意:

- 运行态：==单核处理机环境下，每时刻最多只有一个进程处于运行态。(双核环境下可以同时有两个进程处于运行态)==
- 就绪态：==进程已经拥有了除处理机之外所有需要的资源，一旦获得处理机，即可立即进入运行态开始运行。即:万事俱备，只欠CPU==
- 阻塞态：如:等待操作系统分配打印机、等待读磁盘操作的结果。CPU是计算机中最昂贵的部件，为了提高CPU的利用率，需要先将其他进程需要的资源分配到位，才能得到CPU的服务。==欠其他非cpu资源==

### 另外两种状态

- 创建态：操作系统需要完成创建进程。操作系统为该进程分配所需的内存空间等系统资源，并为其创建、初始化PCB (如:为进程分配PID)

- 终止态：进程运行结束(或者由于bug导致进程无法继续执行下去，比如数组越界错误)，需要撤销进程。
  - 操作系统需要完成撤销进程相关的工作。完成将分配给进程的资源回收，撤销进程PCB等工作

![在这里插入图片描述](F:\bilibili\大笔记\操作系统.assets\20210506144707756.png)

### ==进程状态的转换==

![在这里插入图片描述](F:\bilibili\大笔记\操作系统.assets\20210506144726154.png)

![img](F:\bilibili\大笔记\操作系统.assets\20210506144737635.png)

## 进程控制

> 知识总览
>
> ![img](F:\bilibili\大笔记\操作系统.assets\20210506144753359.png)

进程控制的主要功能是对系统中的所有进程实施有效的管理，它具有创建新进程、撤销已有进程、实现进程状态转换等功能。
简化理解：反正进程控制就是要实现进程状态转换

![在这里插入图片描述](F:\bilibili\大笔记\操作系统.assets\20210506144809684.png)

### 如何实现进程控制？

![image-20210530204938391](F:\bilibili\大笔记\操作系统.assets\image-20210530204938391.png)

细化进程控制过程：

如果进程要被创建，那么他处于创建态，初始化。创建进程，需要初始化pcb（进程控制块），分配资源。

初始化完成之后，将pcb放入就绪队列中。创建态---->就绪态

进程被cpu调度，从就绪队列中摘出来，运行。进程可能之前运行了一半，需要恢复进程运行的环境。就绪态---->运行态

进程用 系统调用 方式申请资源，进程环境就被保存下来，用于之后运行，pcb标志位从运行态改变为阻塞态，pcb放到相应的阻塞队列。运行态---->阻塞态

修改pcb内容，pcb从阻塞队列放到就绪队列当中。阻塞态---->就绪态

![image-20210530210306520](F:\bilibili\大笔记\操作系统.assets\image-20210530210306520.png)





> 用`原语`实现
>
> 原语是一种特殊的程序，它的执行具有`原子性`。也就是说，这段程序的运行必须一气呵成，==不可中断、==

![在这里插入图片描述](F:\bilibili\大笔记\操作系统.assets\20210506144822199.png)

> 思考：`为何进程控制（状态转换）的过程要“一气呵成”？`
>
> 如果不能“一气呵成”，就有可能导致操作系\统中的某些关键数据结构信息不统一的情况，这会影响操作系统进行别的管理工作。

Eg：假设PCB中的变量 state 表示进程当前所处状态，1表示就绪态，2表示阻塞态…

![在这里插入图片描述](F:\bilibili\大笔记\操作系统.assets\20210506144839638.png)

假设此时进程2等待的事件发生，则操作系统中，负责进程控制的内核程序至少需要做这样两件事：
①将PCB2的 state 设为1
②将PCB2从阻塞队列放到就绪队列

完成了第一步后收到中断信号，那么PCB2的state=1，但是它却被放在阻塞队列里

### 如何实现原语的“原子性”？

原语的执行具有原子性，即执行过程只能一气呵成，期间不允许被中断。
可以用“关中断指令”和“开中断指令”这两个特权指令实现原子性
![在这里插入图片描述](F:\bilibili\大笔记\操作系统.assets\20210506144853436.png)

正常情况：CPU每执行完一条指令都会例行检查是否有中断信号需要处理，如果有，则暂停运行当前这段程序，转而执行相应的中断处理程序。

```
CPU执行了关中断指令之后，就不再例行检查中断信号，中断信号被忽略掉，直到执行开中断指令之后才会恢复检查。这样，关中断、开中断之间的这些指令序列就是不可被中断的，这就实现了“原子性”
```

![image-20210530210752129](F:\bilibili\大笔记\操作系统.assets\image-20210530210752129.png)

### 进程控制相关的原语

原语属于操作系统内核的一部分，只能运行在核心态

![image-20210531224043146](F:\bilibili\大笔记\操作系统.assets\image-20210531224043146.png)

#### 创建原语：从无-->创建态-->就绪态

![image-20210531223737677](F:\bilibili\大笔记\操作系统.assets\image-20210531223737677.png)

![在这里插入图片描述](F:\bilibili\大笔记\操作系统.assets\20210506144909647.png)

#### 撤消原语：从就绪、阻塞、运行态-->终止态-->无

![img](F:\bilibili\大笔记\操作系统.assets\20210506144920651.png)

#### 阻塞：运行态-->阻塞态

#### 唤醒：阻塞态-->就绪态

![img](F:\bilibili\大笔记\操作系统.assets\20210506144935442.png)

#### 进程切换

![image-20210531224117860](F:\bilibili\大笔记\操作系统.assets\image-20210531224117860.png)

![img](F:\bilibili\大笔记\操作系统.assets\20210506144955489.png)

![image-20210531224209488](F:\bilibili\大笔记\操作系统.assets\image-20210531224209488.png)

### 知识滚雪球：程序是如何运行的？

![img](F:\bilibili\大笔记\操作系统.assets\20210506145011315.png)

> ![在这里插入图片描述](F:\bilibili\大笔记\操作系统.assets\20210506145023962.png)

> > - 1
> >
> > ![img](F:\bilibili\大笔记\操作系统.assets\20210506145040438.png)

> > - 2
> >
> > ![在这里插入图片描述](F:\bilibili\大笔记\操作系统.assets\20210506145059801.png)

> > - 3
> >
> > ![img](F:\bilibili\大笔记\操作系统.assets\20210506145120125.png)

> > - 4
> >
> > ![在这里插入图片描述](F:\bilibili\大笔记\操作系统.assets\20210506145132405.png)

> ```
> 解决办法：在进程切换时先在PCB中保存这个进程的运行环境（保存一些必要的寄存器信息）
> ```
>
> ![img](F:\bilibili\大笔记\操作系统.assets\202105061451478.png)

#### 进程控制相关的原语

1. 更新PCB中的信息
   a. 所有的进程控制原语一定都会修改进程状态标志
   b. 剥夺当前运行进程的CPU使用权必然需要保存其运行环境
   c. 某进程开始运行前必然要恢复期运行环境
2. 将PCB插入合适的队列
3. 分配 / 回收资源

### 如何实现进程控制

![img](F:\bilibili\大笔记\操作系统.assets\20210506145204110.png)

## 进程通信

> 知识总览
> ![在这里插入图片描述](F:\bilibili\大笔记\操作系统.assets\20210506145251732.png)

### 什么是进程通信？

顾名思义，进程通信就是指进程之间的**信息交换**。

进程是分配系统资源的单位（包括内存地址空间），因此各进程拥有的内存地址空间**相互独立**。

![img](F:\bilibili\大笔记\操作系统.assets\20210506145310313.png)

为了保证安全，一个进程不能直接访问另一个进程的地址空间。

但是进程之间的信息交换又是必须实现的。为了保证进程间的安全通信，操作系统提供了一些方法。

### 进程通信——共享存储

![image-20210531225309742](F:\bilibili\大笔记\操作系统.assets\image-20210531225309742.png)



`基于数据结构`的共享：比如共享空间里只能放一个长度为10的数组。这种共享方式速度慢、限制多，是一种低级通信方式。

`基于存储区`的共享：在内存中画出一块==共享存储区==，数据的形式、存放位置都由进程控制，而不是操作系统。相比之下，这种共享方式速度更快，是一种`高级通信`方式。

### 进程通信——管道通信

“管道”是指用于连接读写进程的一个共享文件，又名pipe文件。==其实就是在内存中开辟一个大小固定的缓冲区==

![img](F:\bilibili\大笔记\操作系统.assets\20210506145344648.png)

1. 管道只能采用`半双工通信`，某一时间段内只能实现单向的传输。如果要实现双向同时通信，则需要设置两个管道。
2. 各进程要`互斥`地访问管道。
3. 数据以字符流的形式写入管道，当管道写满时，写进程的write() 系统调用将被阻塞，等待 读进程 将数据取走。当读进程将数据全部取走后，管道变空，此时读进程的read() 系统调用将被阻塞。**（缓冲区的特性）**
4. ==如果没写满，就不允许读。如果没读空，就不允许写。==**（缓冲区的特性）**
5. `数据一旦被读出，就从管道中被抛弃，这就意味着==读进程最多只能有一个==，否则可能会有读错数据的情况。`

### 进程通信——消息传递

进程间的数据交换以==格式化的消息（Message）==为单位。进程通过操作系统提供的“发送消息 / 接收消息”两个`原语`进行数据交换。

![img](F:\bilibili\大笔记\操作系统.assets\20210506145406491.png)

- 直接消息传递：消息直接挂到接收进程的**消息缓冲队列**上
- 间接消息传递：消息要先发送到中间实体（信箱）中，因此也称“信箱通信方式”。Eg：计网中的电子邮件系统

### 小结

![image-20210531230049016](F:\bilibili\大笔记\操作系统.assets\image-20210531230049016.png)

# 线程 

## 线程的概念和特点

> 知识总览
>
> ![img](F:\bilibili\大笔记\操作系统.assets\20210506145434230.png)

### 什么是线程，为什么要引入线程？

![img](F:\bilibili\大笔记\操作系统.assets\20210506145444426.png)

进程是程序的一次执行。这些功能显然需要用不同的几段程序才能实现，并且这几段程序还要并发运行

![img](F:\bilibili\大笔记\操作系统.assets\20210506145502431.png)

![img](F:\bilibili\大笔记\操作系统.assets\20210506145518417.png)

> 当切换进程时，需要保存 / 恢复进程运行环境，还需要切换内存地址空间（更新快表、更新缓存）开销很大

![img](F:\bilibili\大笔记\操作系统.assets\202105061455388.png)

引入线程后，线程是CPU调度的基本单位（==程序执行流的最小单位==）

### 线程的优点和特性

- 进程间并发，开销很大
  1. 当切换进程时，需要保存 / 恢复进程运行环境，还需要切换内存地址空间（更新快表、更新缓存）
- 线程间并发，开销更小
  1. 同一进程内的各个线程间并发，不需要切换进程运行环境和内存地址空间，省时省力

引入线程机制后，并发带来的系统开销降低，系统并发性提升

> ```
> 注意：从属于不同进程的线程间通信，也必须请求操作系统服务！
> ```

引入线程前，进程既是资源分配的基本单位，也是调度的基本单位。

引入线程后，进程是资源分配的基本单位，线程是调度的基本单位。线程也有运行态、就绪态、阻塞态

在多CPU环境下，各个线程也可以分派到不同的CPU上并行地执行。

线程几乎不拥有资源，只拥有极少量的资源（线程控制块TCB、寄存器信息、堆栈等）

### 小结

![img](F:\bilibili\大笔记\操作系统.assets\20210506145558176.png)

![image-20210601102643089](F:\bilibili\大笔记\操作系统.assets\image-20210601102643089.png)

## 线程的实现方式多线程模型

### 线程的属性

![image-20210601155607496](F:\bilibili\大笔记\操作系统.assets\image-20210601155607496.png)

> 知识总览
>
> ![img](F:\bilibili\大笔记\操作系统.assets\20210506145612404.png)

### 线程的实现方式

#### 用户级：从用户视角可以看到的现场

![image-20210601155921570](F:\bilibili\大笔记\操作系统.assets\image-20210601155921570.png)

历史背景：早期的操作系统（如：早期Unix）只支持进程，不支持线程。当时的“线程”是由线程库实现的

![img](F:\bilibili\大笔记\操作系统.assets\20210506145625241.png)

![img](F:\bilibili\大笔记\操作系统.assets\20210506145638953.png)

从代码的角度看，线程其实就是一段代码逻辑。上述三段代码逻辑上可以看作三个“线程”。while 循环就是一个最弱智的“线程库”，线程库完成了对线程的管理工作（如调度）。

> 很多编程语言提供了强大的线程库，可以实现线程的创建、销毁、调度等功能。

1. 线程的管理工作由谁来完成？

2. 线程切换是否需要CPU变态？

3. 操作系统是否能意识到用户级线程的存在？

4. 这种线程的实现方式有什么优点和缺点？

5. 用户级线程由应用程序通过线程库实现，所有的线程管理工作都由应用程序负责（包括线程切换）

6. 用户级线程中，线程切换可以在用户态下即可完成，无需操作系统干预。

7. 在用户看来，是有多个线程。但是在操作系统内核看来，并意识不到线程的存在。“用户级线程”就是“从用户视角看能看到的线程”

8. 优缺点

   优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统
   开销小，效率高

   缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行。

------

#### 内核级：从操作系统内核角度能看到的线程

![image-20210601160022028](F:\bilibili\大笔记\操作系统.assets\image-20210601160022028.png)

内核级线程（Kernel-Level Thread, KLT, 又称“内核支持的线程”） 由操作系统支持的线程

![在这里插入图片描述](F:\bilibili\大笔记\操作系统.assets\20210506145742221.png)

> 大多数现代操作系统都实现了内核级线程，如Windows、Linux

1. 线程的管理工作由谁来完成？
2. 线程切换是否需要CPU变态？
3. 操作系统是否能意识到内核级线程的存在？
4. 这种线程的实现方式有什么优点和缺点？
5. 内核级线程的管理工作由操作系统内核完成。
6. 线程调度、切换等工作都由内核负责，因此内核级线程的切换必然需要在核心态下才能完成。
7. 操作系统会为每个内核级线程建立相应的TCB（Thread Control Block，线程控制块），通过TCB对线程进行管理。“内核级线程”就是“从操作系统内核视角看能看到的线程”
8. 优缺点

优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行。

缺点：一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大。

### 多线程模型

在支持内核级线程的系统中，根据用户级线程和内核级线程的映射关系，可以划分为几种多线程模型

#### 一对一

一对一模型：一个用户级线程映射到一个内核级线程。每个用户进程有与用户级线程同数量的内核级线程。
![img](F:\bilibili\大笔记\操作系统.assets\20210506145758880.png)

优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行。

缺点：一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大。

#### 多对一

多对一模型：多个用户级线程映射到一个内核级线程。且一个进程只被分配一个内核级线程。
![img](F:\bilibili\大笔记\操作系统.assets\20210506145815581.png)

优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高

缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行

==操作系统只“看得见”内核级线程，因此只有内核级线程才是处理机分配的单位。==

#### 多对多

多对多模型：n 用户级线程映射到m 个内核级线程（n >= m）。每个用户进程对应 m 个内核级线程。

克服了多对一模型并发度不高的缺点（一个阻塞全体阻塞），又克服了一对一模型中一个用户进程占用太多内核级线程，开销太大的缺点。

```markdown
# 可以这么理解：
# 用户级线程是“代码逻辑”的载体
# 内核级线程是“运行机会”的载体
* 一段“代码逻辑”只有获得了“运行机会”才能被CPU执行
1234
```

![img](F:\bilibili\大笔记\操作系统.assets\20210506145838455.png)

内核级线程中可以运行任意一个有映射关系的用户级线程代码，只有两个内核级线程中正在运行的代码逻辑都阻塞时，这个进程才会阻塞

### 小结

![image-20210601160624795](F:\bilibili\大笔记\操作系统.assets\image-20210601160624795.png)

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210506145853642.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDA3NTEzMg==,size_16,color_FFFFFF,t_70)

# 处理机的调度

## 处理机调度概念、层次

> 知识总览
>
> ![在这里插入图片描述](F:\bilibili\大笔记\操作系统.assets\20210506145931264.png)

### 调度的基本概念

![img](https://img-blog.csdnimg.cn/20210506145942297.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDA3NTEzMg==,size_16,color_FFFFFF,t_70)

当有一堆任务要处理，但由于资源有限，这些事情没法同时处理。这就需要==确定某种规则来决定处理这些任务的顺序==，这就是“调度”研究的问题。

在多道程序系统中，进程的数量往往是多于处理机的个数的，这样不可能同时并行地处理各个进程。处理机调度，就是从就绪队列中按照一定的算法选择一个进程并将处理机分配给它运行，以实现进程的并发执行。

### 调度的三个层次

#### 高级调度

![img](https://img-blog.csdnimg.cn/20210506145957668.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDA3NTEzMg==,size_16,color_FFFFFF,t_70)

由于内存空间有限，有时无法将用户提交的作业全部放入内存，因此就需要确定某种规则来决定将作业调入内存的顺序。

高级调度（作业调度）。按一定的原则从外存上处于后备队列的作业中挑选一个（或多个）作业，给他们分配内存等必要资源，并建立相应的进程（建立PCB），以使它（们）获得竞争处理机的权利。

高级调度是辅存（外存）与内存之间的调度。每个作业只调入一次，调出一次。作业调入时会建立相应的PCB，作业调出时才撤销PCB。高级调度主要是指调入的问题，因为只有调入的时机需要操作系统来确定，但调出的时机必然是作业运行结束才调出。

#### 中级调度

![img](https://img-blog.csdnimg.cn/20210506150011732.png)

引入了虚拟存储技术之后，可将暂时不能运行的进程调至外存等待。等它重新具备了运行条件且内存又稍有空闲时，再重新调入内存。

这么做的目的是为了提高内存利用率和系统吞吐量。

暂时调到外存等待的进程状态为挂起状态。值得注意的是，PCB并不会一起调到外存，而是会常驻内存。**PCB中会记录进程数据在外存中的存放位置，进程状态等信息，操作系统通过内存中的PCB**来保持对各个进程的监控、管理。被挂起的进程PCB会被放到的挂起队列中。

中级调度（内存调度），就是要决定将哪个处于挂起状态的进程重新调入内存。

一个进程可能会被多次调出、调入内存，因此中级调度发生的频率要比高级调度更高。

##### 补充知识：进程的挂起态与七状态模型

暂时调到外存等待的进程状态为挂起状态（挂起态，suspend）
挂起态又可以进一步细分为就绪挂起、阻塞挂起两种状态
五状态模型 -----> 七状态模型

![在这里插入图片描述](https://img-blog.csdnimg.cn/2021050615002451.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDA3NTEzMg==,size_16,color_FFFFFF,t_70)

注意“挂起”和“阻塞”的区别，两种就绪挂起 状态都是暂时不能获得CPU的服务，但挂起态是将进程映像调到外存去了，而
阻塞态下进程映像还在内存中。

有的操作系统会把就绪挂起、阻塞挂起分为两个挂起队列，甚至会根据阻塞原因不同再把阻塞挂起进程进一步细分为阻塞挂起 多个队列。

#### 低级调度

![img](https://img-blog.csdnimg.cn/20210506150036446.png)

低级调度（进程调度），其主要任务是按照某种方法和策略从就绪队列中选取一个进程，将处理机分配给它。

进程调度是操作系统中最基本的一种调度，在一般的操作系统中都必须配置进程调度。
进程调度的频率很高，一般几十毫秒一次。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210506150053987.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDA3NTEzMg==,size_16,color_FFFFFF,t_70)

### 小结

![img](https://img-blog.csdnimg.cn/20210506150104532.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDA3NTEzMg==,size_16,color_FFFFFF,t_70)

## 进程调度的时机切换与过程调度方式

> 知识总览
>
> ![img](https://img-blog.csdnimg.cn/20210506150114745.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDA3NTEzMg==,size_16,color_FFFFFF,t_70)

### 进程调度的时机

进程调度（低级调度），就是按照某种算法从就绪队列中选择一个进程为其分配处理机。

![img](https://img-blog.csdnimg.cn/2021050615013284.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDA3NTEzMg==,size_16,color_FFFFFF,t_70)

临界资源：一个时间段内只允许一个进程使用的资源。各进程需要互斥地访问临界资源。
临界区：访问临界资源的那段代码。

内核程序临界区一般是用来访问某种内核数据结构的，比如进程的就绪队列（由各就绪进程的PCB组成）

> 有的系统中，只允许进程主动放弃处理机有的系统中，进程可以主动放弃处理机，当有更紧急的任务需要处理时，也会强行剥夺处理机（被动放弃）

```
进程在普通临界区中是可以进行调度、切换的。
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210506150148297.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDA3NTEzMg==,size_16,color_FFFFFF,t_70)

### 进程调度的方式

`非剥夺调度方式`，又称非抢占方式。即，只允许进程主动放弃处理机。在运行过程中即便有更紧迫的任务到达，当前进程依然会继续使用处理机，直到该进程终止或主动要求进入阻塞态。

```markdown
# 实现简单，系统开销小但是无法及时处理紧急任务，适合于早期的批处理系统
1
```

`剥夺调度方式`，又称抢占方式。当一个进程正在处理机上执行时，如果有一个更重要或更紧迫的进程需要使用处理机，则立即暂停正在执行的进程，将处理机分配给更重要紧迫的那个进程。

```markdown
# 可以优先处理更紧急的进程，也可实现让各进程按时间片轮流执行的功能（通过时钟中断）。适合于分时操作系统、实时操作系统
1
```

### 进程的切换与过程

“狭义的进程调度”与“进程切换”的区别：

狭义的进程调度指的是从就绪队列中选中一个要运行的进程。（这个进程可以是刚刚被暂停执行的进程，也可能是另一个进程，后一种情况就需要进程切换）

进程切换是指一个进程让出处理机，由另一个进程占用处理机的过程。

#### 过程

广义的进程调度包含了选择一个进程和进程切换两个步骤。
进程切换的过程主要完成了：

1. 对原来运行进程各种数据的保存
2. 对新的进程各种数据的恢复
   （如：程序计数器、程序状态字、各种数据寄存器等处理机现场信息，这些信息一般保存在进程控制块）

注意：进程切换是有代价的，因此如果过于频繁的进行进程调度、切换，必然会使整个系统的效率降低，使系统大部分时间都花在了进程切换上，而真正用于执行进程的时间减少。

### 小结

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210506150208106.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDA3NTEzMg==,size_16,color_FFFFFF,t_70)

## 调度算法的评价指标

> 知识总览
>
> ![在这里插入图片描述](https://img-blog.csdnimg.cn/20210506150219719.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDA3NTEzMg==,size_16,color_FFFFFF,t_70)

### CPU利用率

由于早期的CPU造价极其昂贵，因此人们会希望让CPU尽可能多地工作

`CPU利用率`：指CPU “忙碌”的时间占总时间的比例。

利 用 率 = 忙 碌 的 时 间 / 总 时 间 利用率 = 忙碌的时间 / 总时间利用率=忙碌的时间/总时间
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210506150229620.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDA3NTEzMg==,size_16,color_FFFFFF,t_70)

### 系统吞吐量

对于计算机来说，希望能用尽可能少的时间处理完尽可能多的作业

`系统吞吐量`：单位时间内完成作业的数量
系 统 吞 吐 量 = 总 共 完 成 了 多 少 道 作 业 / 总 共 花 了 多 少 时 间 系统吞吐量 = 总共完成了多少道作业 / 总共花了多少时间系统吞吐量=总共完成了多少道作业/总共花了多少时间
Eg：某计算机系统处理完10道作业，共花费100秒，则系统吞吐量为？
10/100 = 0.1 道 / 秒

### 周转时间

对于计算机的用户来说，他很关心自己的作业从提交到完成花了多少时间。

`周转时间`，是指从作业被提交给系统开始，到作业完成为止的这段时间间隔。

它包括四个部分：

- 作业在外存后备队列上等待作业调度（高级调度）的时间、
- 进程在就绪队列上等待进程调度（低级调度）的时间、
- 进程在CPU上执行的时间、
- 进程等待I/O操作完成的时间。

后三项在一个作业的整个处理过程中，可能发生多次

对于用户来说，更关心自己的单个作业的周转时间
（ 作 业 ） 周 转 时 间 = 作 业 完 成 时 间 – 作 业 提 交 时 间 （作业）周转时间= 作业完成时间– 作业提交时间（作业）周转时间=作业完成时间–作业提交时间
对于操作系统来说，更关心系统的整体表现， 因此更关心所有作业周转时间的平均值
平 均 周 转 时 间 = 各 作 业 周 转 时 间 之 和 / 作 业 数 平均周转时间 = 各作业周转时间之和 / 作业数平均周转时间=各作业周转时间之和/作业数
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210506150255292.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDA3NTEzMg==,size_16,color_FFFFFF,t_70)

### 周转时间

带权周转时间必然≥ 1
带 权 周 转 时 间 = 作 业 周 转 时 间 / 作 业 实 际 运 行 的 时 间 = ( 作 业 完 成 时 间 – 作 业 提 交 时 间 ) / 作 业 实 际 运 行 的 时 间 带权周转时间 = 作业周转时间 / 作业实际运行的时间 = (作业完成时间– 作业提交时间) / 作业实际运行的时间带权周转时间=作业周转时间/作业实际运行的时间=(作业完成时间–作业提交时间)/作业实际运行的时间

平 均 带 权 周 转 时 间 = 各 作 业 带 权 周 转 时 间 之 和 / 作 业 数 平均带权周转时间=各作业带权周转时间之和/作业数平均带权周转时间=各作业带权周转时间之和/作业数
带权周转时间与周转时间都是越小越好
![img](https://img-blog.csdnimg.cn/20210506150310919.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDA3NTEzMg==,size_16,color_FFFFFF,t_70)

### 等待时间

计算机的用户希望自己的作业尽可能少的等待处理机

`等待时间`，指进程 / 作业处于等待处理机状态时间之和，等待时间越长，用户满意度越低。

![img](https://img-blog.csdnimg.cn/20210506150322912.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDA3NTEzMg==,size_16,color_FFFFFF,t_70)

对于进程来说，等待时间就是指进程建立后等待被服务的时间之和，在等待I/O完成的期间其实进程也是在被服务的，所以不计入等待时间。

对于作业来说，不仅要考虑建立进程后的等待时间，还要加上作业在外存后备队列中等待的时间。

> 一个作业总共需要被CPU服务多久，被I/O设备服务多久一般是确定不变的，因此调度算法其实只会影响作业 / 进程的等待时间。当然，与前面指标类似，也有“平均等待时间”来评价整体性能。

### 响应时间

对于计算机用户来说，会希望自己的提交的请求（比如通过键盘输入了一个调试命令）尽早地开始被系统服务、回应。

`响应时间`，指从用户提交请求到首次产生响应所用的时间。

### 小结

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210506150344160.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDA3NTEzMg==,size_16,color_FFFFFF,t_70)

## 调度算法

> 知识总览
>
> ![img](https://img-blog.csdnimg.cn/20210506150354868.png)

> Tips：各种调度算法的学习思路
>
> 1. 算法思想
> 2. 算法规则
> 3. 这种调度算法是用于作业调度还是进程调度？
> 4. 抢占式？非抢占式？
> 5. 优点和缺点
> 6. 是否会导致饥饿
>
> `饥饿`:某进程 / 作业长期得不到服务.

### 先来先服务（FCFS, First Come First Serve）

按照作业 / 进程到达的先后顺序进行服务

用于作业 / 进程调度: 用于作业调度时，考虑的是哪个作业先到达后备队列；用于进程调度时，考虑的是哪个进程先到达就绪队列

非抢占式的算法

优点：公平、算法实现简单
缺点：排在长作业（进程）后面的短作业需要等待很长时间，带权周转时间很大，对短作业来说用户体验不好。即，FCFS算法对长作业有利，对短作业不利（Eg ：排队买奶茶…）

不会产生饥饿现象

![在这里插入图片描述](https://img-blog.csdnimg.cn/2021050615041251.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDA3NTEzMg==,size_16,color_FFFFFF,t_70)

### 短作业优先（SJF, Shortest Job First）

算法思想：追求最少的平均等待时间，最少的平均周转时间、最少的平均平均带权周转时间

算法规则： 最短的作业 / 进程优先得到服务（所谓“最短”，是指要求服务时间最短）

即可用于作业调度，也可用于进程调度。用于进程调度时称为“短进程优先（SPF, Shortest Process First）算法”

SJF和SPF是非抢占式的算法。但是也有抢占式的版本——最短剩余时间优先算法（SRTN, Shortest Remaining Time Next）

则

> 1. 这种调度算法是用于作业调度还是进程调度？
> 2. 抢占式？非抢占式？
> 3. 优点和缺点
> 4. 是否会导致饥饿
>
> `饥饿`:某进程 / 作业长期得不到服务.

### 短作业优先（SJF, Shortest Job First）

算法思想：追求最少的平均等待时间，最少的平均周转时间、最少的平均平均带权周转时间

算法规则： 最短的作业 / 进程优先得到服务（所谓“最短”，是指要求服务时间最短）

即可用于作业调度，也可用于进程调度。用于进程调度时称为“短进程优先（SPF, Shortest Process First）算法”

SJF和SPF是非抢占式的算法。但是也有抢占式的版本——最短剩余时间优先算法（SRTN, Shortest Remaining Time Next）



